var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { NgModule, ViewChild, Component, Input, Output, EventEmitter, QueryList, ContentChildren, ElementRef, Renderer } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PortalModule, coerceBooleanProperty } from '../core';
import { VdlTabLabel } from './tab-label';
import { VdlTabLabelWrapper } from './tab-label-wrapper';
import { VdlTabNavBar, VdlTabLink } from './tab-nav-bar/tab-nav-bar';
import { VdlInkBar } from './ink-bar';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import { ObserveContentModule } from '../core/observe-content/observe-content';
import { VdlTab } from './tab';
import { VdlTabBody } from './tab-body';
import { VIEWPORT_RULER_PROVIDER } from '../core/overlay/position/viewport-ruler';
import { VdlTabHeader } from './tab-header';
import { SCROLL_DISPATCHER_PROVIDER } from '../core/overlay/scroll/scroll-dispatcher';
/** Used to generate unique ID's for each tab component */
var nextId = 0;
/** A simple change event emitted on focus or selection changes. */
export var VdlTabChangeEvent = (function () {
    function VdlTabChangeEvent() {
    }
    return VdlTabChangeEvent;
}());
/**
 * Material design tab-group component.  Supports basic tab pairs (label + content) and includes
 * animated ink-bar, keyboard navigation, and screen reader.
 * See: https://www.google.com/design/spec/components/tabs.html
 */
export var VdlTabGroup = (function () {
    function VdlTabGroup(_renderer) {
        this._renderer = _renderer;
        /** Whether this component has been initialized. */
        this._isInitialized = false;
        /** The tab index that should be selected after the content has been checked. */
        this._indexToSelect = 0;
        /** Snapshot of the height of the tab body wrapper before another tab is activated. */
        this._tabBodyWrapperHeight = null;
        /** Whether the tab group should grow to the size of the active tab */
        this._dynamicHeight = false;
        this._selectedIndex = null;
        /** Position of the tab header. */
        this.headerPosition = 'above';
        this._onFocusChange = new EventEmitter();
        this._onSelectChange = new EventEmitter(true);
        this._groupId = nextId++;
    }
    Object.defineProperty(VdlTabGroup.prototype, "dynamicHeight", {
        get: function () { return this._dynamicHeight; },
        set: function (value) { this._dynamicHeight = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VdlTabGroup.prototype, "_dynamicHeightDeprecated", {
        /** @deprecated */
        get: function () { return this._dynamicHeight; },
        set: function (value) { this._dynamicHeight = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VdlTabGroup.prototype, "selectedIndex", {
        get: function () { return this._selectedIndex; },
        /** The index of the active tab. */
        set: function (value) { this._indexToSelect = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VdlTabGroup.prototype, "selectedIndexChange", {
        /** Output to enable support for two-way binding on `selectedIndex`. */
        get: function () {
            return this.selectChange.map(function (event) { return event.index; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VdlTabGroup.prototype, "focusChange", {
        /** Event emitted when focus has changed within a tab group. */
        get: function () {
            return this._onFocusChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VdlTabGroup.prototype, "selectChange", {
        /** Event emitted when the tab selection has changed. */
        get: function () {
            return this._onSelectChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be. This is where we can know exactly what position
     * each tab should be in according to the new selected index, and additionally we know how
     * a new selected tab should transition in (from the left or right).
     */
    VdlTabGroup.prototype.ngAfterContentChecked = function () {
        var _this = this;
        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which
        // ensures that values like NaN can't get through and which would otherwise throw the
        // component into an infinite loop (since Math.max(NaN, 0) === NaN).
        this._indexToSelect =
            Math.min(this._tabs.length - 1, Math.max(this._indexToSelect || 0, 0));
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex != this._indexToSelect && this._selectedIndex != null) {
            this._onSelectChange.emit(this._createChangeEvent(this._indexToSelect));
        }
        // Setup the position for each tab and optionally setup an origin on the next selected tab.
        this._tabs.forEach(function (tab, index) {
            tab.position = index - _this._indexToSelect;
            // If there is already a selected tab, then set up an origin for the next selected tab
            // if it doesn't have one already.
            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
                tab.origin = _this._indexToSelect - _this._selectedIndex;
            }
        });
        this._selectedIndex = this._indexToSelect;
    };
    /**
     * Waits one frame for the view to update, then updates the ink bar
     * Note: This must be run outside of the zone or it will create an infinite change detection loop.
     */
    VdlTabGroup.prototype.ngAfterViewChecked = function () {
        this._isInitialized = true;
    };
    VdlTabGroup.prototype._focusChanged = function (index) {
        this._onFocusChange.emit(this._createChangeEvent(index));
    };
    VdlTabGroup.prototype._createChangeEvent = function (index) {
        var event = new VdlTabChangeEvent;
        event.index = index;
        if (this._tabs && this._tabs.length) {
            event.tab = this._tabs.toArray()[index];
        }
        return event;
    };
    /** Returns a unique id for each tab label element */
    VdlTabGroup.prototype._getTabLabelId = function (i) {
        return "vdl-tab-label-" + this._groupId + "-" + i;
    };
    /** Returns a unique id for each tab content element */
    VdlTabGroup.prototype._getTabContentId = function (i) {
        return "vdl-tab-content-" + this._groupId + "-" + i;
    };
    /**
     * Sets the height of the body wrapper to the height of the activating tab if dynamic
     * height property is true.
     */
    VdlTabGroup.prototype._setTabBodyWrapperHeight = function (tabHeight) {
        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
            return;
        }
        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', this._tabBodyWrapperHeight + 'px');
        // This conditional forces the browser to paint the height so that
        // the animation to the new height can have an origin.
        if (this._tabBodyWrapper.nativeElement.offsetHeight) {
            this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', tabHeight + 'px');
        }
    };
    /** Removes the height of the tab body wrapper. */
    VdlTabGroup.prototype._removeTabBodyWrapperHeight = function () {
        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;
        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', '');
    };
    __decorate([
        ContentChildren(VdlTab), 
        __metadata('design:type', QueryList)
    ], VdlTabGroup.prototype, "_tabs", void 0);
    __decorate([
        ViewChild('tabBodyWrapper'), 
        __metadata('design:type', ElementRef)
    ], VdlTabGroup.prototype, "_tabBodyWrapper", void 0);
    __decorate([
        Input(), 
        __metadata('design:type', Boolean)
    ], VdlTabGroup.prototype, "dynamicHeight", null);
    __decorate([
        Input('vdl-dynamic-height'), 
        __metadata('design:type', Boolean)
    ], VdlTabGroup.prototype, "_dynamicHeightDeprecated", null);
    __decorate([
        Input(), 
        __metadata('design:type', Number), 
        __metadata('design:paramtypes', [Number])
    ], VdlTabGroup.prototype, "selectedIndex", null);
    __decorate([
        Input(), 
        __metadata('design:type', String)
    ], VdlTabGroup.prototype, "headerPosition", void 0);
    __decorate([
        Output(), 
        __metadata('design:type', Observable)
    ], VdlTabGroup.prototype, "selectedIndexChange", null);
    __decorate([
        Output(), 
        __metadata('design:type', Observable)
    ], VdlTabGroup.prototype, "focusChange", null);
    __decorate([
        Output(), 
        __metadata('design:type', Observable)
    ], VdlTabGroup.prototype, "selectChange", null);
    VdlTabGroup = __decorate([
        Component({selector: 'vdl-tab-group',
            template: "<vdl-tab-header [selectedIndex]=\"selectedIndex\" #tabHeader (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"vdl-tab-label\" role=\"tab\" vdl-tab-label-wrapper *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [tabIndex]=\"selectedIndex == i ? 0 : -1\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [class.vdl-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" (click)=\"tabHeader.focusIndex = selectedIndex = i\"><template [ngIf]=\"tab.templateLabel\"><template [cdkPortalHost]=\"tab.templateLabel\"></template></template><template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</template></div></vdl-tab-header><div class=\"vdl-tab-body-wrapper\" #tabBodyWrapper><vdl-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.vdl-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" (onCentered)=\"_removeTabBodyWrapperHeight()\" (onCentering)=\"_setTabBodyWrapperHeight($event)\"></vdl-tab-body></div>",
            styles: [":host{display:flex;flex-direction:column;font-family:Roboto,sans-serif}:host.vdl-tab-group-inverted-header{flex-direction:column-reverse}.vdl-tab-label{line-height:40px;height:40px;margin:0;padding:0 15px;font-size:16px;font-family:Roboto,sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:#414142;min-width:160px;text-align:center;border-radius:3px;transition:border-bottom 4ms ease-in-out 3ms;position:relative}.vdl-tab-label.focus,.vdl-tab-label:focus{outline:0}.vdl-tab-label.hover,.vdl-tab-label:hover{background-color:#f3f3f3}.vdl-tab-label.vdl-tab-label-active,.vdl-tab-label.vdl-tab-link-active{color:#005a99}.vdl-tab-label.vdl-tab-disabled{cursor:default;pointer-events:none;color:#a5a5a5}@media (max-width:600px){.vdl-tab-label{min-width:72px}}:host[vdl-stretch-tabs] .vdl-tab-label{flex-basis:0;flex-grow:1}.vdl-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}vdl-tab-body{position:absolute;top:0;left:0;right:0;bottom:0;display:block;overflow:hidden}vdl-tab-body.vdl-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}:host.vdl-tab-group-dynamic-height vdl-tab-body.vdl-tab-body-active{overflow-y:hidden}"],
            host: {
                '[class.vdl-tab-group-dynamic-height]': 'dynamicHeight',
                '[class.vdl-tab-group-inverted-header]': 'headerPosition === "below"',
            }
        }), 
        __metadata('design:paramtypes', [Renderer])
    ], VdlTabGroup);
    return VdlTabGroup;
}());
export var VdlTabsModule = (function () {
    function VdlTabsModule() {
    }
    /** @deprecated */
    VdlTabsModule.forRoot = function () {
        return {
            ngModule: VdlTabsModule,
            providers: []
        };
    };
    VdlTabsModule = __decorate([
        NgModule({
            imports: [CommonModule, PortalModule, ObserveContentModule],
            // Don't export all components because some are only to be used internally.
            exports: [VdlTabGroup, VdlTabLabel, VdlTab, VdlTabNavBar, VdlTabLink],
            declarations: [VdlTabGroup, VdlTabLabel, VdlTab, VdlInkBar, VdlTabLabelWrapper,
                VdlTabNavBar, VdlTabLink, VdlTabBody, VdlTabHeader],
            providers: [VIEWPORT_RULER_PROVIDER, SCROLL_DISPATCHER_PROVIDER],
        }), 
        __metadata('design:paramtypes', [])
    ], VdlTabsModule);
    return VdlTabsModule;
}());
//# sourceMappingURL=tab-group.js.map